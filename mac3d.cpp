#include "mac.h"#include "common.hpp"#include "psx.h"#include "d3d.h"#include "main.h"#include "atirave.h"#include "pcdef.h"#include "handler.h"#include "nu3d.h"#include "d3dframe.h"#include "txtrsys.h"#define MAXTXTRNAME (80)typedef struct txtrcon_s {	LLTXTR pub;	char name[MAXTXTRNAME+1];	unsigned long flags;	int refcnt;	struct txtrcon_s *succ, *prev;} TXTRCON;extern D3DAppInfo d3dappi;extern CD3DFramework *d3dframe;D3DMATRIX WorldMatrix, ViewMatrix, ProjectionMatrix;D3DMATRIX WorldViewMatrix;/****************************************************************//* defines														*//****************************************************************/#define MAX_ENGINE			5int renderWidth,renderHeight;int displayWidth,displayHeight;TQAIndexedTriangle* triangleArray = new TQAIndexedTriangle[2000];TQAIndexedTriangle* triangle;int vertexCount,triangleCount;bool jjsFadeHack = false;bool smallMemory = false;VIEWPORT Macvp;D3DMATERIAL Macmat;BOOL InitDirectX(void);int widthBy2;int heightBy2;bool TextureSet=false;float oneOverFarMinusNear;float zmod = 0.0f;//#define SetZ(z) ((z - global_camera.nearclip) * oneOverFarMinusNear)#define SetZ(z) ((z - global_camera.nearclip) * oneOverFarMinusNear + zmod)/* * macro to load fields of TQAVTexture */#define ST( _v,_x,_y,_z,_invW,_a,_r,_g,_b,_uOverW,_vOverW,_kd_r,_kd_g,_kd_b,_ks_r,_ks_g,_ks_b ) \{												 			\	(_v).x 		= (_x);										\	(_v).y 		= (_y);										\	(_v).z 		= (_z);										\	(_v).invW 	= (_invW);									\	(_v).a 		= (_a);										\	(_v).r 		= (_r);										\	(_v).g 		= (_g);										\	(_v).b 		= (_b);										\	(_v).uOverW = (_uOverW);								\	(_v).vOverW = (_vOverW);								\	(_v).kd_r 	= (_kd_r);									\	(_v).kd_g 	= (_kd_g);									\	(_v).kd_b 	= (_kd_b);									\	(_v).ks_r 	= (_ks_r);									\	(_v).ks_g 	= (_ks_g);									\	(_v).ks_b 	= (_ks_b);									\}#define SetRect( R, l, t, r, b )	(R)->left = (l), (R)->top = (t), (R)->right = (r), (R)->bottom = (b)/****************************************************************//* typedefs														*//****************************************************************/typedef unsigned char UINT8;typedef unsigned short UINT16;typedef long INT32;typedef unsigned long UINT32;/****************************************************************//* global variables												*//****************************************************************//* * RAVE variables */GDHandle		gGDevice;TQADevice   	gDevice;TQAEngine   	*gEngine;TQADrawContext  *gDrawContext;TQATexture 		*gpTex;TQABitmap 		*gpBit;TQAImage 		gImageTex;TQAImage 		gImageBit;TQAImagePixelType pixelType;unsigned long	gflags = kQAContext_DoubleBuffer;TQARect         gRect;TQAEngine 		*EngineList[MAX_ENGINE] = { NULL, NULL, NULL, NULL, NULL };char			EngineNames[MAX_ENGINE][100];unsigned long	gEngineID = 0;/* * window variables */MenuHandle		gAppleMenu;MenuHandle		gFileMenu;MenuHandle		gControlMenu;MenuHandle		gEngineMenu;Boolean 		gbDone = false;Boolean			gbTexAlpha = true;Boolean			gbATIcard = false;int				gNumEngines = 0;WindowPtr		winPtr = NULL;Rect			winRect = { 0, 0, 480, 640 };RGBColor		BLACK = { 0, 0, 0 };GWorldPtr		newGW;char 			str[256];const long clipFlagNone = 0;const long clipFlagFront = 1;const long clipFlagBack = 2;const long clipFlagLeft = 4;const long clipFlagRight = 8;const long clipFlagTop = 16;const long clipFlagBottom = 32;const long clipFlagAll = 63;short TextureSize[D3DAPP_MAXTEXTURES][2];			/* texture sizes */long	TexturePall[D3DAPP_MAXTEXTURES];			/* TRUE - texture is palettized. */short TextureSYSMEM[D3DAPP_MAXTEXTURES];			/* TRUE - load into VRAM, FALSE - load into system memory */char *TPage[D3DAPP_MAXTEXTURES];void ttCreateVertexBuffer(short i, BOOL create);void __cdecl Log(char *format, ...);char *TypeToStr(long type){	switch (type)  {		case (D3DTEXTURE_TYPE_NULL):			return("D3DTEXTURE_TYPE_NULL");			break;		case (D3DTEXTURE_TYPE_8BIT_PALL):			return("D3DTEXTURE_TYPE_8BIT_PALL");			break;		case (D3DTEXTURE_TYPE_16BIT_RGB):			return("D3DTEXTURE_TYPE_16BIT_RGB");			break;		case (D3DTEXTURE_TYPE_24BIT_RGB):			return("D3DTEXTURE_TYPE_24BIT_RGB");			break;		case (D3DTEXTURE_TYPE_32BIT_RGB):			return("D3DTEXTURE_TYPE_32BIT_RGB");			break;		case (D3DTEXTURE_TYPE_8BIT_PLAIN):			return("D3DTEXTURE_TYPE_8BIT_PLAIN");			break;		case (D3DTEXTURE_TYPE_16BIT_PLAIN):			return("D3DTEXTURE_TYPE_16BIT_PLAIN");			break;		default:			return("UNKNOWN");			break;  }}void FreeTPage(long i){	long l;	if(!TPage[i]) return;	jjsfree(TPage[i]);	for(l=0; l < D3DAPP_MAXTEXTURES; l++)	{		if(TPage[l] == TPage[i] && i!=l && TPage[i] && TPage[l])		{			TPage[l] = 0;			TPageJH[l] = 0;		}	}	TPage[i] = 0;	TPageJH[i] = 0;}// Find a texture format that matches the tpage type.TQAImagePixelType D3DAppIMatchTextureFormat(short n){	switch (d3dappi.TextureType[n])	{			case D3DTEXTURE_TYPE_NULL:				break;			case D3DTEXTURE_TYPE_16BIT_PLAIN:			case D3DTEXTURE_TYPE_16BIT_RGB:				return kQAPixel_ARGB16;			case D3DTEXTURE_TYPE_24BIT_RGB:			case D3DTEXTURE_TYPE_32BIT_RGB:				return kQAPixel_RGB32;			case D3DTEXTURE_TYPE_8BIT_PLAIN:			case D3DTEXTURE_TYPE_8BIT_PALL:				Log("FAILURE to map tpage %d as a 8 bit palettized surface - searching for 16bit instead.\n",n);				return kQAPixel_ARGB16;	}	return(kQAPixel_Alpha1);	// dummy value}/***************************************************************************//* Loading a playstation texture page into D3D *//***************************************************************************/void* D3DAppILoadSurfaceRAW(DWORD tpagenum, TQAImagePixelType Format){//	lpDirectDrawSurface lpDDS;//	DDSurfaceDesc ddsd, format;//	D3DCOLOR colors[256];//	D3DCOLOR c;	DWORD dwWidth, dwHeight, alpha;	int i, j;	FILE *fp;	char *lpC;//	LPDIRECTDRAWPALETTE lpDDPal;	PALETTEENTRY ppe[256];	int psize;	DWORD pcaps;	int color_count;	BOOL bQuant = FALSE;//	HRESULT ddrval;	char *lpTpage, pix;	int pixelSize;	void* surface;	dwWidth  = TextureSize[tpagenum][0];	dwHeight = TextureSize[tpagenum][1];	lpTpage = TPage[tpagenum];	if (!lpTpage)		return (NULL);	switch(Format)	{		case kQAPixel_ARGB16:			pixelSize=2;			break;		case kQAPixel_RGB32:			pixelSize=4;			break;		case kQAPixel_CL8:			pixelSize=1;			break;	}	surface = jjsmalloc(dwWidth * dwHeight * pixelSize);	/*	 * 16 bit format.	 */	if (pixelSize>1)	{		unsigned long *lpLP;		unsigned short *lpSP;		unsigned char *lpCP;		unsigned long m;		int s;//		int red_shift, red_scale;//		int green_shift, green_scale;//		int blue_shift, blue_scale;		int alpha_shift, alpha_scale;		/*		 * Determine the red, green and blue masks' shift and scale.		 */		if(pixelSize==2)		{			d3dappi.red_shift[tpagenum] = 10;			d3dappi.red_scale[tpagenum] = 255 / 31;			d3dappi.green_shift[tpagenum] = 5;			d3dappi.green_scale[tpagenum] = 255 / 31;			d3dappi.blue_shift[tpagenum] = 0;			d3dappi.blue_scale[tpagenum] = 255 / 31;			alpha = 0;		}		else		{			d3dappi.red_shift[tpagenum] = 16;			d3dappi.red_scale[tpagenum] = 255 / 255;			d3dappi.green_shift[tpagenum] = 8;			d3dappi.green_scale[tpagenum] = 255 / 255;			d3dappi.blue_shift[tpagenum] = 0;			d3dappi.blue_scale[tpagenum] = 255 / 255;			alpha = 0;		}		/*		 * Each RGB bit count requires different pointers		 */		switch (pixelSize)		{			case 4:				for (j = 0; j < (int) dwHeight; j++)				{					/*					 * Point to next row in texture surface					 */					lpLP = (unsigned long *) (((char *) surface) +								  dwWidth * j);					for (i = 0; i < (int) dwWidth; i++)					{						int r, g, b, a;						/*						 * Read each value, scale it and shift it into position						 */						r = *lpTpage++ / d3dappi.red_scale[tpagenum];						g = *lpTpage++ / d3dappi.green_scale[tpagenum];						b = *lpTpage++ / d3dappi.blue_scale[tpagenum];						*lpLP = (r << d3dappi.red_shift[tpagenum]) | (g << d3dappi.green_shift[tpagenum]) |							(b << d3dappi.blue_shift[tpagenum]) | alpha;						lpLP++;					}				}				break;			case 2:				// It's possible we are loading an 8bit tpage into a 16bit surface - so adjust the copy if so.				switch (d3dappi.TextureType[tpagenum])			  {					default:						// normal						lpSP = (unsigned short *)surface;						for (j = 0; j < (int) dwHeight; j++)						{//							lpSP = (unsigned short *) (((char *) surface) +//										   dwWidth * j);							for (i = 0; i < (int) dwWidth; i++)							{								int r, g, b, a;																r = *lpTpage++ / d3dappi.red_scale[tpagenum];								g = *lpTpage++ / d3dappi.green_scale[tpagenum];								b = *lpTpage++ / d3dappi.blue_scale[tpagenum];								if(g==0x1f && r == 0 & b == 0)									a=0;								else									a=1<<15;								*lpSP = (r << d3dappi.red_shift[tpagenum]) | (g << d3dappi.green_shift[tpagenum]) |									(b << d3dappi.blue_shift[tpagenum]) | a;								lpSP++;							}						}						break;					case D3DTEXTURE_TYPE_8BIT_PALL:						// Load 8bit into 16bit surface.						memset(ppe, 0, sizeof(PALETTEENTRY) * 256);						for (i = 0; i < 256; i++)						{							ppe[i].peRed = (unsigned char) 		d3dappi.TextureCLUT[tpagenum][(i*3)+0];							ppe[i].peGreen = (unsigned char) 	d3dappi.TextureCLUT[tpagenum][(i*3)+1];							ppe[i].peBlue = (unsigned char) 	d3dappi.TextureCLUT[tpagenum][(i*3)+2];						}						lpSP = (unsigned short *)surface;						for (j = 0; j < (int) dwHeight; j++)						{//							lpSP = (unsigned short *) (((char *) surface) + dwWidth * j);							for (i = 0; i < (int) dwWidth; i++)							{								int r, g, b, a;								pix = *lpTpage++;								r = ppe[pix].peRed / d3dappi.red_scale[tpagenum];								g = ppe[pix].peGreen / d3dappi.green_scale[tpagenum];								b = ppe[pix].peBlue / d3dappi.blue_scale[tpagenum];								if(g==0x1f && r == 0 & b == 0)									a=0;								else									a=1<<15;								*lpSP++ = (r << d3dappi.red_shift[tpagenum]) | (g << d3dappi.green_shift[tpagenum]) |									(b << d3dappi.blue_shift[tpagenum]) | a;							}						}						break;			  }				break;			case 1:				for (j = 0; j < (int) dwHeight; j++)				{					lpCP = (unsigned char *) (((char *) surface) +								  dwWidth * j);					for (i = 0; i < (int) dwWidth; i++)					{						int r, g, b, a;						r = *lpTpage++ / d3dappi.red_scale[tpagenum];						g = *lpTpage++ / d3dappi.green_scale[tpagenum];						b = *lpTpage++ / d3dappi.blue_scale[tpagenum];						*lpCP = (r << d3dappi.red_shift[tpagenum]) | (g << d3dappi.green_shift[tpagenum]) |							(b << d3dappi.blue_shift[tpagenum]) | alpha;						lpCP++;					}				}				break;			default:				/*				 * This wasn't a format I recognize				 */				 jjsfree(surface);				return NULL;		}		/*		 * Unlock the texture and return the surface pointer		 */		{#if !defined(MAC)			DDCOLORKEY ckey;			int r, g, b, a;			r = (0 		/ d3dappi.red_scale[tpagenum])		<< d3dappi.red_shift[tpagenum];			g = (255 	/ d3dappi.green_scale[tpagenum])	<< d3dappi.green_shift[tpagenum];			b = (0 		/ d3dappi.blue_scale[tpagenum])		<< d3dappi.blue_shift[tpagenum];			ckey.dwColorSpaceLowValue = (DWORD) (alpha|r|g|b);			ckey.dwColorSpaceHighValue = ckey.dwColorSpaceLowValue;			D3DCALL(lpDDS->SetColorKey(DDCKEY_SRCBLT, &ckey));#endif		}		return (surface);	}#if 0	/*	 * 8 bit format.	 */	color_count = 0;					     /* number of colors in the texture */	colour_key = 0;	memset(ppe, 0, sizeof(PALETTEENTRY) * 256);	for (i = 0; i < 256; i++)	{		ppe[i].peRed = (unsigned char) 		d3dappi.TextureCLUT[tpagenum][(i*3)+0];		ppe[i].peGreen = (unsigned char) 	d3dappi.TextureCLUT[tpagenum][(i*3)+1];		ppe[i].peBlue = (unsigned char) 	d3dappi.TextureCLUT[tpagenum][(i*3)+2];	}	colour_key = -1;	for(i=0; i<256; i++)	{		if(ppe[i].peRed == 0 && ppe[i].peGreen > 250 && ppe[i].peBlue == 0)		{			ppe[i].peGreen = 255;			colour_key = i;			break;		}	}	d3dappi.TextureColourKey[tpagenum] = colour_key;	for (j = 0; j < (int) dwHeight; j++)	{		/*		 * Point to next row in surface		 */		lpC = ((char *) ddsd.lpSurface) + ddsd.lPitch * j;		for (i = 0; i < (int) dwWidth; i++)		{			pix = *lpTpage++;			if(ppe[pix].peRed == 0 && ppe[pix].peGreen > 250 && ppe[pix].peBlue == 0)				*lpC++ = colour_key;			else				*lpC++ = pix;		}	}	/*	 * Close the file and unlock the surface	 */	D3DCALL(lpDDS->Unlock(NULL));	if(colour_key >= 0)	{		DDCOLORKEY ckey;		ckey.dwColorSpaceLowValue = colour_key;		ckey.dwColorSpaceHighValue = colour_key;		D3DCALL(lpDDS->SetColorKey(DDCKEY_SRCBLT, &ckey));	}	/*	 * Create the palette with the DDPCAPS_ALLOW256 flag because we want to	 * have access to all entries.	 */	D3DCALL(lpDD->CreatePalette(DDPCAPS_INITIALIZE | pcaps, ppe, &lpDDPal, NULL));	/*	 * Finally, bind the palette to the surface	 */	D3DCALL(lpDDS->SetPalette(lpDDPal));	lpDDPal->Release();	return lpDDS;#endif}BOOL D3DAppILoadTextureSurf(int n, BOOL * bInVideo){	TQAImagePixelType format;	TQAImage* im;//	DDSurfaceDesc ddsd;	void* lpSrcTextureSurf = NULL;//	lpDirect3DTexture lpSrcTexture = NULL;//	LPDIRECTDRAWPALETTE lpDstPalette = NULL;//	PALETTEENTRY ppe[256];	DWORD pcaps;	Log("TEXTURES : TPage %d is %s.\n", n, (TexturePall[n]) ? "8bit palletized format" : "16bit raw format");	/*	 * Release the surface if it is hanging around	 */	RELEASE(d3dappi.lpTextureSurf[n]);	/*	 * Create a surface in system memory and load the PPM file into it.	 * Query for the texture interface.	 */	format = (D3DAppIMatchTextureFormat(n));	if(format == NULL)		return(FALSE);			d3dappi.lpTextureSurf[n] = D3DAppILoadSurfaceRAW( n, format);	if (!d3dappi.lpTextureSurf[n])		goto exit_with_error;		im = d3dappi.lpImage[n] = (TQAImage*)jjsmalloc(sizeof(TQAImage));	im->width  = TextureSize[n][0];	im->height  = TextureSize[n][1];	im->rowBytes = im->width * 2; //temp jjs	im->pixmap = d3dappi.lpTextureSurf[n];	QATextureNew(gEngine,kQATexture_None,format,im,&d3dappi.lpTexture[n]);	QATextureDetach(gEngine,d3dappi.lpTexture[n]);#if !defined(MAC)	if (pcaps)	{		memset(ppe, 0, sizeof(PALETTEENTRY) * 256);		D3DCALL(d3dappi.lpDD->CreatePalette(pcaps, ppe, &lpDstPalette, NULL));		D3DCALL(d3dappi.lpTextureSurf[n]->SetPalette(lpDstPalette));	}#endif//	d3dappi.TextureStatus[n] = D3DTEXTURE_STATUS_READY;	return TRUE;exit_with_error:	RELEASE(d3dappi.lpTextureSurf[n]);	RELEASE(d3dappi.lpImage[n]);	return FALSE;}BOOL D3DMaintainTextures(){	BOOL bInVideo;	long i, rescan, err;		do	{		rescan = FALSE;		for (i = 0; i < D3DAPP_MAXTEXTURES; i++)		{			switch (d3dappi.TextureStatus[i])		  {				case D3DTEXTURE_STATUS_NULL:				case D3DTEXTURE_STATUS_DESTROYED:					break;				case D3DTEXTURE_STATUS_READY:					break;				case D3DTEXTURE_STATUS_ISLOST:					break;				// Delete D3D tpage texture interface and surface.				case D3DTEXTURE_STATUS_DESTROY:				case D3DTEXTURE_STATUS_RELOAD:					if(d3dappi.TextureStatus[i] == D3DTEXTURE_STATUS_DESTROY)					{						ttCreateVertexBuffer(i, FALSE);		// destroy any vertex buffer for this tpage.						if(TPage[i])						{							FreeTPage(i);							Log("MEM : Pixel buffer for tpage %d destroyed.\n",i);						}						TPage[i] = 0;						TPageJH[i] = (unsigned short *)0;					}					TexturePall[i] = FALSE;//					if( d3dappi.lpTexture[i] )//						QATextureDelete( gEngine, d3dappi.lpTexture[i] );//						RELEASE(d3dappi.lpTexture[i]);//						RELEASE(d3dappi.lpTextureORIG[i]);//						RELEASE(d3dappi.lpTextureSurf[i]);//						RELEASE(d3dappi.lpTextureSurfORIG[i]);//						RELEASE(d3dappi.lpTextureMat[i]);//						d3dappi.lpTextureMatHandle[i] = 0;//						MasterTextureHandle[i] = 0;						d3dappi.TextureBLIT[i] = FALSE;					d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_NULL;					break;									// Tpage loaded, so init.				case D3DTEXTURE_STATUS_LOADED:						Log("TEXTURES : Attempting to create tpage %d, type %s, size %dx%d\n",i,TypeToStr(d3dappi.TextureType[i]),														TextureSize[i][0],TextureSize[i][1]);						if(!D3DAppILoadTextureSurf(i,&bInVideo))						{							Log("D3DTEXTURE_STATUS_LOADED failed, tpage %d \n",i);							d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_DESTROY;							rescan = TRUE;							break;						}						if(!TextureSYSMEM[i])						{							if (!bInVideo)							{								/*								 * If a texture fails to load into video memory for a hardware								 * device, make sure we remove it..								 */								Log("ERROR : TPage %d failed to load into hardware video ram, destroying...\n",i);								d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_DESTROY;								rescan = TRUE;								break;							}						}					d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_GETHANDLE;					rescan = TRUE;					break;				// Get the texture handle.				case D3DTEXTURE_STATUS_GETHANDLE://						if(D3DAppIGetTextureHandle(i))//						{							d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_READY;							ttCreateVertexBuffer(i, TRUE);		// create the vertex buffer for this tpage.//						}//						else//						{//							Log("D3DTEXTURE_STATUS_GETHANDLE failed, tpage %d \n",i);//							d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_DESTROY;//							rescan = TRUE;//							break;//						}					d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_READY;					d3dappi.TextureBLIT[i] = FALSE;										break;		  }		}	}	while(rescan == TRUE);	return(TRUE);}void FindWindowContentRect( WindowPtr pWin, Rect *r ){	GrafPtr	oldPort;	Point	leftTop;	Point	rightBot;		GetPort( &oldPort );		SetPort( pWin );	SetPt( &leftTop, pWin->portRect.left, pWin->portRect.top );	SetPt( &rightBot, pWin->portRect.right, pWin->portRect.bottom );		LocalToGlobal( &leftTop );	LocalToGlobal( &rightBot );		SetRect( r, leftTop.h, leftTop.v, rightBot.h, rightBot.v );		SetPort( oldPort );}/* * Function:	FindWindowDevice() * */GDHandle FindWindowDevice( WindowPtr pWin ){	GDHandle	hDevice;	Rect		rWin;	Rect		intersect;		if( pWin == NULL )		return( NULL );		//	rWin = ((*(((WindowPeek)pWin)->strucRgn))->rgnBBox);	rWin = ((*(((WindowPeek)pWin)->contRgn))->rgnBBox);		for( hDevice = GetDeviceList(); 		 hDevice; 		 hDevice = GetNextDevice(hDevice) )	{		/*		 * test for active monitors that entirely contain rect		 */		if( TestDeviceAttribute(hDevice, screenDevice) &&			TestDeviceAttribute(hDevice, screenActive) &&			SectRect(&rWin, &((*hDevice)->gdRect), &intersect) &&			EqualRect(&rWin, &intersect) )		{			return( hDevice );		}		}	return( NULL );	}TQAEngine *FindEngine( TQADevice *device ){	TQAEngine 	*tmpEngine;	UINT32		vendorID;	char		Response[200];	int			i, len;	int			saveEngineID;	Str255		menuStr;	MenuHandle	menuHndl	= gEngineMenu;	unsigned long multiTextureMax, textureMemory;		saveEngineID 	= gEngineID;	gEngineID		= 0;		/*	 * list all RAVE engines	 */	for( tmpEngine = QADeviceGetFirstEngine(device);		 tmpEngine;		 tmpEngine = QADeviceGetNextEngine(device, tmpEngine) )	{		QAEngineGestalt( tmpEngine, kQAGestalt_ASCIIName, Response );				/*		 * see if engine is already in list		 */		for( i = 0; i < gNumEngines; i++ )		{			if( strcmp(Response, EngineNames[i]) == 0 )			{				EngineList[i] = tmpEngine;				if( i == saveEngineID )					gEngineID = i;				break;			}		}		/*		 * if engine is not already in list add it		 */				if( i == gNumEngines )		{			EngineList[gNumEngines] = tmpEngine;			strcpy( EngineNames[gNumEngines], Response );					if( ++gNumEngines == MAX_ENGINE )				break;		}	}			if( gEngineID >= gNumEngines )		gEngineID = 0;		QAEngineGestalt( EngineList[gEngineID], kQAGestalt_VendorID, &vendorID );			gbATIcard 	= (vendorID == 1);	if(gbATIcard)	{		QAEngineGestalt( EngineList[gEngineID], kQAGestalt_MultiTextureMax, &multiTextureMax );			if(multiTextureMax==0)		// must be Rage II		{			renderWidth = 320;			renderHeight = 240;			QAEngineGestalt( EngineList[gEngineID], kQAGestalt_TextureMemory, &textureMemory );				if(textureMemory < 1700000)				smallMemory = true;		}		else		{			renderWidth = 640;			renderHeight = 480;		}		}	return( EngineList[gEngineID] );}BOOL InitRave(){	Rect	r;		if( (gGDevice =  FindWindowDevice(winPtr)) == NULL )	{     	printf( "ERROR: No monitors found\n" );     	return( false );	}	gDevice.deviceType 		= kQADeviceGDevice;	gDevice.device.gDevice 	= gGDevice;		if( (gEngine = FindEngine( &gDevice )) == NULL )	{	     printf( "ERROR: No Engine available\n" );	     return( false );	}	if( QAEngineCheckDevice( gEngine, &gDevice ) )	{	     printf( "ERROR: EngineCheckDevice failed\n" );	     return( false );	}	FindWindowContentRect( winPtr, &r );	OffsetRect( &r, -(**gGDevice).gdRect.left, -(**gGDevice).gdRect.top );	displayWidth = 640;	displayHeight = 480;		widthBy2 = renderWidth / 2;	heightBy2 = renderHeight / 2;	gRect.left 		= 0; 	gRect.top  		= 0;  	gRect.right  	= renderWidth;	gRect.bottom 	= renderHeight;	d3dframe->m_rcViewportRect.left = gRect.left; 	d3dframe->m_rcViewportRect.top = gRect.top; 	d3dframe->m_rcViewportRect.right = gRect.right; 	d3dframe->m_rcViewportRect.bottom = gRect.bottom; 		Macvp.dwX = gRect.left;	Macvp.dwY = gRect.top;	d3dframe->m_dwRenderWidth = Macvp.dwWidth = gRect.right - gRect.left;	d3dframe->m_dwRenderHeight = Macvp.dwHeight = gRect.bottom - gRect.top;	Macvp.dvMinZ = 0.0f;	Macvp.dvMaxZ = 1.0f;	Macvp.dvClipX = -1.0f;	Macvp.dvClipWidth = 2.0f;	Macvp.dvClipHeight = 2.0f;	Macvp.dvClipY = 1.0f;						/*	 * create a draw context + set background color for clearing	 */	if( QADrawContextNew(&gDevice,&gRect,0,gEngine,gflags,&gDrawContext) != kQANoErr )	{	     printf( "ERROR: Context create failed\n" );	     return( false );	}		d3dappi.gDrawContext = gDrawContext;	QASetFloat( d3dappi.gDrawContext, kQATag_ColorBG_a, 1.0 );	QASetFloat( d3dappi.gDrawContext, kQATag_ColorBG_r, 0.0 );	QASetFloat( d3dappi.gDrawContext, kQATag_ColorBG_g, 0.0 );	QASetFloat( d3dappi.gDrawContext, kQATag_ColorBG_b, 0.0 );	QASetInt(d3dappi.gDrawContext, kQATag_TextureOp, kQATextureOp_Modulate);	QASetInt(d3dappi.gDrawContext, kQATag_ZFunction, kQAZFunction_LE);	QASetInt(d3dappi.gDrawContext, kQATag_Blend, kQABlend_OpenGL);	QASetInt(d3dappi.gDrawContext, kQATagGL_BlendSrc, GL_ONE);	QASetInt(d3dappi.gDrawContext, kQATagGL_BlendDst, GL_ZERO);	QASetInt(d3dappi.gDrawContext, (TQATagInt)kATITriCache, 0);	QASetInt(d3dappi.gDrawContext, kQATag_ZBufferMask, kQAZBufferMask_Enable);	QASetInt(d3dappi.gDrawContext, (TQATagInt)kATICullMode, GL_FRONT);	if(renderWidth==320)	{		QASetInt(d3dappi.gDrawContext, (TQATagInt)kATIScaleBlit, 1);		QASetInt(d3dappi.gDrawContext, (TQATagInt)kATIScaleLeft, 0);		QASetInt(d3dappi.gDrawContext, (TQATagInt)kATIScaleTop, 0);		QASetInt(d3dappi.gDrawContext, (TQATagInt)kATIScaleRight, 640);		QASetInt(d3dappi.gDrawContext, (TQATagInt)kATIScaleBottom, 480);	}	return( InitDirectX() );}BOOL Rave(){return TRUE;}BOOL DestroyRave(){	int i;	for(i=0;i<D3DAPP_MAXTEXTURES; ++i)		if(d3dappi.TextureStatus[i] != D3DTEXTURE_STATUS_NULL)			d3dappi.TextureStatus[i] = D3DTEXTURE_STATUS_DESTROY;				D3DMaintainTextures();	if( d3dappi.gDrawContext )		QADrawContextDelete( d3dappi.gDrawContext );}HRESULT MacCreateVertexBuffer(LPD3DVERTEXBUFFERDESC lpVBDesc, LPVOID* lpD3DVertexBuffer, DWORD dwFlags){	int size;	long *p;		switch(lpVBDesc->dwFVF)	{		case VRTHD_UTUL:			size = 32;			break;		case VRTHD_C:			size = 36;			break;		case VRTHD_TL:			size = 36;			break;		default:			return -1;	}	p = (long *)jjsmalloc(lpVBDesc->dwNumVertices * size + 8);	*lpD3DVertexBuffer = p;	*p++=lpVBDesc->dwNumVertices * size;	*p++ = dwFlags;	return D3D_OK;	}HRESULT MacProcessVertices(void* DestBuff,DWORD VertexOp, DWORD DestIndex, DWORD count, void* SrcBuff, DWORD SrcIndex, DWORD flags){	int *p =(int *)SrcBuff;	VTX_C *sv = (VTX_C *)(p+2);	sv+=SrcIndex;	p =(int *)DestBuff;	VTX_TL *dd = (VTX_TL *)(p+2);	dd+=DestIndex;	VTX_TL *v;	int i,j;	float temp;		// temp w value	LONG tempx, tempy, tempw, tempfar;	ULONG cc,clipflag,c1,c2,c3;		for(i=0;i<count;++i,++sv,++dd)	{		dd->pnt.x = (sv->pnt.x * WorldViewMatrix._11 + sv->pnt.y* WorldViewMatrix._21 +  sv->pnt.z*WorldViewMatrix._31 + WorldViewMatrix._41) * ProjectionMatrix._11;		dd->pnt.y = (sv->pnt.x * WorldViewMatrix._12 + sv->pnt.y* WorldViewMatrix._22 +  sv->pnt.z*WorldViewMatrix._32 + WorldViewMatrix._42) * ProjectionMatrix._22;		temp = dd->pnt.z = (sv->pnt.x * WorldViewMatrix._13 + sv->pnt.y* WorldViewMatrix._23 +  sv->pnt.z*WorldViewMatrix._33 + WorldViewMatrix._43) * ProjectionMatrix._33 + ProjectionMatrix._43;				dd->diffuse = *(int *)&sv->diffuse;		dd->u = sv->u;		dd->v = sv->v;						// now set flags		dd->flags = 0;		if(temp < global_camera.nearclip)			dd->flags |= clipFlagFront;		else		{			cc = 0;			temp = 1.0f / temp;			tempw = *((LONG *) (&dd->pnt.z));			tempx = (*((LONG *) (&dd->pnt.x))) & 0x7FFFFFFF;			tempy = (*((LONG *) (&dd->pnt.y))) & 0x7FFFFFFF;			tempfar = *((LONG *) (&global_camera.farclip));			if (tempw < tempy)			{				cc += 2 - ((*((ULONG *) (&dd->pnt.y))) >> 31);			}			cc <<= 2;			if (tempw < tempx)			{				cc += 2 - ((*((ULONG *) (&dd->pnt.x))) >> 31);			}			cc <<= 2;			if (tempw > tempfar)			{				cc += 2;			}			dd->flags = cc;		}				}	return D3D_OK;}HRESULT MacSetMaterial(LPD3DMATERIAL mat){	Macmat = *mat;}HRESULT MacSetTransform(int type, LPD3DMATRIX lpD3DMatrix){	static int stackdepth = 0;	switch(type)	{		case D3DTRANSFORMSTATE_WORLD:			WorldMatrix = *lpD3DMatrix;			matrixMul((matrix *)&WorldViewMatrix,(matrix *)&WorldMatrix,(matrix *)&ViewMatrix);			break;		case D3DTRANSFORMSTATE_VIEW:			ViewMatrix = *lpD3DMatrix;			break;		case D3DTRANSFORMSTATE_PROJECTION:			ProjectionMatrix = *lpD3DMatrix;			break;	}}static TQAVTexture v1[10000];static TQAVGouraud vg[1000];int strip[2][3]={	{0,1,2},	{0,2,1}};HRESULT MacDrawIndexedPrimitive(D3DPRIMITIVETYPE d3dptPrimitiveType,  	DWORD  dwVertexTypeDesc,                LPVOID lpvVertices,                   	DWORD  dwVertexCount,                   LPWORD lpwIndices,                    	DWORD  dwIndexCount,                    DWORD  dwFlags){	int j;	switch(d3dptPrimitiveType)	{		case D3DPT_TRIANGLESTRIP:			VTX_TL *v = (VTX_TL *)lpvVertices;					if(TextureSet)			{				for(j=0;j<dwVertexCount;++j)				{					COL32* tc;									v1[j].x = v[j].pnt.x;					v1[j].y = v[j].pnt.y;					v1[j].z = v[j].pnt.z;					v1[j].invW = v[j].rhw;					v1[j].uOverW = v[j].u * v[j].rhw;					v1[j].vOverW = v[j].v * v[j].rhw;					tc = (COL32 *)&v[j].diffuse;					v1[j].kd_r = tc->comp.r/255.0;					v1[j].kd_g = tc->comp.g/255.0;					v1[j].kd_b = tc->comp.b/255.0;					v1[j].a = tc->comp.a/255.0;				}							for(j=0;j<dwIndexCount-2;j++)					QADrawTriTexture(d3dappi.gDrawContext,&v1[lpwIndices[j+strip[j&1][0]]],&v1[lpwIndices[j+strip[j&1][1]]],&v1[lpwIndices[j+strip[j&1][2]]],kQATriFlags_None);			}			else			{				for(j=0;j<dwVertexCount;++j)				{					COL32* tc;									vg[j].x = v[j].pnt.x;					vg[j].y = v[j].pnt.y;					vg[j].z = v[j].pnt.z;					vg[j].invW = v[j].rhw;					tc = (COL32 *)&v[j].diffuse;					vg[j].r = tc->comp.r/255.0;					vg[j].g = tc->comp.g/255.0;					vg[j].b = tc->comp.b/255.0;					vg[j].a = tc->comp.a/255.0;				}							for(j=0;j<dwIndexCount-2;j++)					QADrawTriGouraud(d3dappi.gDrawContext,&vg[lpwIndices[j+strip[j&1][0]]],&vg[lpwIndices[j+strip[j&1][1]]],&vg[lpwIndices[j+strip[j&1][2]]],kQATriFlags_None);			}			break;	}}HRESULT MacDrawPrimitive(D3DPRIMITIVETYPE d3dptPrimitiveType,  	DWORD  dwVertexTypeDesc,                LPVOID lpvVertices,                   	DWORD  dwVertexCount,                  DWORD  dwFlags){	int j;	switch(dwVertexTypeDesc)	{		case VRTHD_TL:			switch(d3dptPrimitiveType)			{				case D3DPT_TRIANGLELIST:					VTX_TL *v = (VTX_TL *)lpvVertices;					if(TextureSet)					{						for(j=0;j<dwVertexCount;++j)						{							COL32* tc;													v1[j].x = v[j].pnt.x;							v1[j].y = v[j].pnt.y;							v1[j].z = v[j].pnt.z;							v1[j].invW = v[j].rhw;							v1[j].uOverW = v[j].u * v[j].rhw;							v1[j].vOverW = v[j].v * v[j].rhw;							tc = (COL32 *)&v[j].diffuse;							v1[j].kd_r = tc->comp.r/255.0;							v1[j].kd_g = tc->comp.g/255.0;							v1[j].kd_b = tc->comp.b/255.0;							v1[j].a = tc->comp.a/255.0;						}											for(j=0;j<dwVertexCount;j+=3)							QADrawTriTexture(d3dappi.gDrawContext,&v1[j],&v1[j+1],&v1[j+2],kQATriFlags_None);					}					else					{						for(j=0;j<dwVertexCount;++j)						{							COL32* tc;													vg[j].x = v[j].pnt.x;							vg[j].y = v[j].pnt.y;							vg[j].z = v[j].pnt.z;							vg[j].invW = v[j].rhw;							tc = (COL32 *)&v[j].diffuse;							vg[j].r = tc->comp.r/255.0;							vg[j].g = tc->comp.g/255.0;							vg[j].b = tc->comp.b/255.0;							vg[j].a = tc->comp.a/255.0;						}											for(j=0;j<dwVertexCount;j+=3)							QADrawTriGouraud(d3dappi.gDrawContext,&vg[j],&vg[j+1],&vg[j+2],kQATriFlags_None);					}					break;			}	}}extern "C" {void MacEnumTextureFormatsAndCreate(TEXTURESEARCHINFO* tsi, TXTRCON* t){	TQAImagePixelType PixType;	int pixelSize;		if(tsi->alpha)		PixType = tsi->desiredBPP == 16?kQAPixel_ARGB16:kQAPixel_RGB32;	else		PixType = tsi->desiredBPP == 16?kQAPixel_RGB16:kQAPixel_RGB32;	pixelSize = tsi->desiredBPP == 16? 2 : 4;	t->pub.ddsurface = jjsmalloc(t->pub.w * t->pub.h * pixelSize);		t->pub.image.width = t->pub.w;	t->pub.image.height = t->pub.h;	t->pub.image.rowBytes = t->pub.w * pixelSize;	t->pub.image.pixmap = t->pub.ddsurface;	t->pub.PixType = PixType;	tsi->fmt_ok = TRUE;}};void InterpolateVertices(const TQAVTextureFlags *v1,			const TQAVTextureFlags *v2, float t, TQAVTextureFlags *newVertex){	float omt = 1.0 - t;		newVertex->x = omt * v1->x + t * v2->x;	newVertex->y = omt * v1->y + t * v2->y;	newVertex->z = omt * v1->z + t * v2->z;	newVertex->kd_r = v1->kd_r + t * (v2->kd_r - v1->kd_r);	newVertex->kd_g = v1->kd_g + t * (v2->kd_g - v1->kd_g);	newVertex->kd_b = v1->kd_b + t * (v2->kd_b - v1->kd_b);	newVertex->a = v1->a + t * (v2->a - v1->a);		newVertex->uOverW = v1->uOverW + t * (v2->uOverW - v1->uOverW);	newVertex->vOverW = v1->vOverW + t * (v2->vOverW - v1->vOverW);	newVertex->flags = 0;	if(newVertex->x > newVertex->z)		newVertex->flags |= clipFlagRight;	if(newVertex->x < -newVertex->z)		newVertex->flags |= clipFlagLeft;	if(newVertex->y > newVertex->z)		newVertex->flags |= clipFlagBottom;	if(newVertex->y < -newVertex->z)		newVertex->flags |= clipFlagTop;}void MacClipTriangle(const TQAIndexedTriangle *triangle,			long clipFlags){	TQAIndexedTriangle		t;		float d = global_camera.nearclip;		long i1 = triangle->vertices[0];	long i2 = triangle->vertices[1];	long i3 = triangle->vertices[2];		const TQAVTextureFlags *vv1 = (TQAVTextureFlags *)&v1[i1];	const TQAVTextureFlags *vv2 = (TQAVTextureFlags *)&v1[i2];	const TQAVTextureFlags *vv3 = (TQAVTextureFlags *)&v1[i3];		if (clipFlags & clipFlagFront)		// Clip against front plane.	{		float d1 = vv1->z - d;		float d2 = vv2->z - d;		float d3 = vv3->z - d;				long b1 = (vv1->flags & clipFlagFront)?1:0;		// Vertex 1 on negative side?		long b2 = (vv2->flags & clipFlagFront)?1:0;		// Vertex 2 on negative side?		long b3 = (vv3->flags & clipFlagFront)?1:0;		// Vertex 3 on negative side?				// Count number of vertices on negative side of plane.		long b = b1 + b2 + b3;		if (b != 0)		{			if (b == 1)	// One vertex is on the negative side.			{						// Find out which one it is.				if (b1)				{					// Chop original triangle down to a smaller quadrilateral.  Modify					// the original triangle to serve as one half of the quad and create					// a new triangle to fill in the other half.					i1 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), v);					InterpolateVertices(vv1, vv3, d1 / (d1 - d3),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i;					t.vertices[1] = i1;					t.vertices[2] = i3;					vv1 = v;				}				else if (b2)				{					i2 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), v);					InterpolateVertices(vv2, vv1, d2 / (d2 - d1),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i1;					t.vertices[1] = i;					t.vertices[2] = i2;					vv2 = v;				}				else				{					i3 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), v);					InterpolateVertices(vv3, vv2, d3 / (d3 - d2),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i3;					t.vertices[1] = i2;					t.vertices[2] = i;					vv3 = v;				}				// Clip new triangle recursively to preserve order.				// New triangle doesnÕt need to be clipped against front plane again.				MacClipTriangle(&t, clipFlags & (clipFlagLeft |					clipFlagRight | clipFlagTop | clipFlagBottom));				}			else if (b == 2)	// Two vertices are on the negative side.			{								// Find out which one is NOT.				if (!b1)				{					// Chop original triangle down to smaller triangle.					i2 = vertexCount++;					i3 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv2, vv1, d2 / (d2 - d1), v);					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), w);					vv2 = v;					vv3 = w;				}				else if (!b2)				{					i3 = vertexCount++;					i1 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv3, vv2, d3 / (d3 - d2), v);					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), w);					vv3 = v;					vv1 = w;				}				else				{					i1 = vertexCount++;					i2 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv1, vv3, d1 / (d1 - d3), v);					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), w);					vv1 = v;					vv2 = w;				}			}			else return;	// All three vertices on negative side -- reject triangle.		}	}		if (clipFlags & clipFlagLeft)	// Clip against left plane.	{		// Calculate dot product of each vertex position with planeÕs normal.		float d1 = vv1->z + vv1->x;				float d2 = vv2->z + vv2->x;				float d3 = vv3->z + vv3->x;				long b1 = (vv1->flags & clipFlagLeft)?1:0;		long b2 = (vv2->flags & clipFlagLeft)?1:0;		long b3 = (vv3->flags & clipFlagLeft)?1:0;				long b = b1 + b2 + b3;		if (b != 0)		{			if (b == 1)			{				if (b1)				{					i1 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), v);					InterpolateVertices(vv1, vv3, d1 / (d1 - d3),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i;					t.vertices[1] = i1;					t.vertices[2] = i3;					vv1 = v;				}				else if (b2)				{					i2 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), v);					InterpolateVertices(vv2, vv1, d2 / (d2 - d1),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i1;					t.vertices[1] = i;					t.vertices[2] = i2;					vv2 = v;				}				else				{					i3 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), v);					InterpolateVertices(vv3, vv2, d3 / (d3 - d2),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i3;					t.vertices[1] = i2;					t.vertices[2] = i;					vv3 = v;				}								MacClipTriangle(&t, clipFlags & (clipFlagRight |					clipFlagTop | clipFlagBottom));			}			else if (b == 2)			{				if (!b1)				{					i2 = vertexCount++;					i3 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv2, vv1, d2 / (d2 - d1), v);					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), w);					vv2 = v;					vv3 = w;				}				else if (!b2)				{					i3 = vertexCount++;					i1 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv3, vv2, d3 / (d3 - d2), v);					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), w);					vv3 = v;					vv1 = w;				}				else				{					i1 = vertexCount++;					i2 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv1, vv3, d1 / (d1 - d3), v);					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), w);					vv1 = v;					vv2 = w;				}			}			else return;		}	}		if (clipFlags & clipFlagRight)	{		float d1 = vv1->z - vv1->x;		float d2 = vv2->z - vv2->x;		float d3 = vv3->z - vv3->x;				long b1 = (vv1->flags & clipFlagRight)?1:0;		long b2 = (vv2->flags & clipFlagRight)?1:0;		long b3 = (vv3->flags & clipFlagRight)?1:0;				long b = b1 + b2 + b3;		if (b != 0)		{			if (b == 1)			{				if (b1)				{					i1 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), v);					InterpolateVertices(vv1, vv3, d1 / (d1 - d3),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i;					t.vertices[1] = i1;					t.vertices[2] = i3;					vv1 = v;				}				else if (b2)				{					i2 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), v);					InterpolateVertices(vv2, vv1, d2 / (d2 - d1),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i1;					t.vertices[1] = i;					t.vertices[2] = i2;					vv2 = v;				}				else				{					i3 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), v);					InterpolateVertices(vv3, vv2, d3 / (d3 - d2),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i3;					t.vertices[1] = i2;					t.vertices[2] = i;					vv3 = v;				}								MacClipTriangle(&t, clipFlags & (clipFlagTop |					clipFlagBottom));			}			else if (b == 2)			{				if (!b1)				{					i2 = vertexCount++;					i3 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv2, vv1, d2 / (d2 - d1), v);					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), w);					vv2 = v;					vv3 = w;				}				else if (!b2)				{					i3 = vertexCount++;					i1 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv3, vv2, d3 / (d3 - d2), v);					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), w);					vv3 = v;					vv1 = w;				}				else				{					i1 = vertexCount++;					i2 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv1, vv3, d1 / (d1 - d3), v);					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), w);					vv1 = v;					vv2 = w;				}			}			else return;		}	}		if (clipFlags & clipFlagTop)	{		float d1 = vv1->z + vv1->y;		float d2 = vv2->z + vv2->y;		float d3 = vv3->z + vv3->y;				long b1 = (vv1->flags & clipFlagTop)?1:0;		long b2 = (vv2->flags & clipFlagTop)?1:0;		long b3 = (vv3->flags & clipFlagTop)?1:0;				long b = b1 + b2 + b3;		if (b != 0)		{			if (b == 1)			{				if (b1)				{					i1 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), v);					InterpolateVertices(vv1, vv3, d1 / (d1 - d3),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i;					t.vertices[1] = i1;					t.vertices[2] = i3;					vv1 = v;				}				else if (b2)				{					i2 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), v);					InterpolateVertices(vv2, vv1, d2 / (d2 - d1),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i1;					t.vertices[1] = i;					t.vertices[2] = i2;					vv2 = v;				}				else				{					i3 = vertexCount++;					long i = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), v);					InterpolateVertices(vv3, vv2, d3 / (d3 - d2),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i3;					t.vertices[1] = i2;					t.vertices[2] = i;					vv3 = v;				}								MacClipTriangle(&t, clipFlags & clipFlagBottom);			}			else if (b == 2)			{				if (!b1)				{					i2 = vertexCount++;					i3 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i2];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i3];					InterpolateVertices(vv2, vv1, d2 / (d2 - d1), v);					InterpolateVertices(vv3, vv1, d3 / (d3 - d1), w);					vv2 = v;					vv3 = w;				}				else if (!b2)				{					i3 = vertexCount++;					i1 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i3];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i1];					InterpolateVertices(vv3, vv2, d3 / (d3 - d2), v);					InterpolateVertices(vv1, vv2, d1 / (d1 - d2), w);					vv3 = v;					vv1 = w;				}				else				{					i1 = vertexCount++;					i2 = vertexCount++;					TQAVTextureFlags *v = (TQAVTextureFlags *)&v1[i1];					TQAVTextureFlags *w = (TQAVTextureFlags *)&v1[i2];					InterpolateVertices(vv1, vv3, d1 / (d1 - d3), v);					InterpolateVertices(vv2, vv3, d2 / (d2 - d3), w);					vv1 = v;					vv2 = w;				}			}			else return;		}	}		if (clipFlags & clipFlagBottom)	{		float d1 = vv1->z - vv1->y;		float d2 = vv2->z - vv2->y;		float d3 = vv3->z - vv3->y;				long b1 = (vv1->flags & clipFlagBottom)?1:0;		long b2 = (vv2->flags & clipFlagBottom)?1:0;		long b3 = (vv3->flags & clipFlagBottom)?1:0;				long b = b1 + b2 + b3;		if (b != 0)		{			if (b == 1)			{				if (b1)				{					i1 = vertexCount++;					long i = vertexCount++;					InterpolateVertices(vv1, vv2, d1 / (d1 - d2),						(TQAVTextureFlags *)&v1[i1]);					InterpolateVertices(vv1, vv3, d1 / (d1 - d3),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i;					t.vertices[1] = i1;					t.vertices[2] = i3;				}				else if (b2)				{					i2 = vertexCount++;					long i = vertexCount++;					InterpolateVertices(vv2, vv3, d2 / (d2 - d3),						(TQAVTextureFlags *)&v1[i2]);					InterpolateVertices(vv2, vv1, d2 / (d2 - d1),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i1;					t.vertices[1] = i;					t.vertices[2] = i2;				}				else				{					i3 = vertexCount++;					long i = vertexCount++;					InterpolateVertices(vv3, vv1, d3 / (d3 - d1),						(TQAVTextureFlags *)&v1[i3]);					InterpolateVertices(vv3, vv2, d3 / (d3 - d2),						(TQAVTextureFlags *)&v1[i]);					t.vertices[0] = i3;					t.vertices[1] = i2;					t.vertices[2] = i;				}								MacClipTriangle(&t, clipFlagNone);			}			else if (b == 2)			{				if (!b1)				{					i2 = vertexCount++;					i3 = vertexCount++;					InterpolateVertices(vv2, vv1, d2 / (d2 - d1),						(TQAVTextureFlags *)&v1[i2]);					InterpolateVertices(vv3, vv1, d3 / (d3 - d1),						(TQAVTextureFlags *)&v1[i3]);				}				else if (!b2)				{					i3 = vertexCount++;					i1 = vertexCount++;					InterpolateVertices(vv3, vv2, d3 / (d3 - d2),						(TQAVTextureFlags *)&v1[i3]);					InterpolateVertices(vv1, vv2, d1 / (d1 - d2),						(TQAVTextureFlags *)&v1[i1]);				}				else				{					i1 = vertexCount++;					i2 = vertexCount++;					InterpolateVertices(vv1, vv3, d1 / (d1 - d3),						(TQAVTextureFlags *)&v1[i1]);					InterpolateVertices(vv2, vv3, d2 / (d2 - d3),						(TQAVTextureFlags *)&v1[i2]);				}			}			else return;		}	}		// Add clipped triangle to the triangle array.	TQAIndexedTriangle *newTriangle = &triangleArray[triangleCount++];		newTriangle->vertices[0] = i1;	newTriangle->vertices[1] = i2;	newTriangle->vertices[2] = i3;}HRESULT MacSetTexture(int stage, TQATexture* texture){	if(!texture)		TextureSet = false;	else	{		TextureSet = true;		QASetPtr(d3dappi.gDrawContext,kQATag_Texture, texture);	}}HRESULT MacDrawIndexedPrimitiveVB(D3DPRIMITIVETYPE d3dptPrimitiveType,  LPVOID vBuff,                   	 LPWORD lpwIndices, DWORD  dwIndexCount, DWORD  dwFlags){	if(TextureSet)	{		int *p =(int *)vBuff;		int tVert;		VTX_TL *v;		v = (VTX_TL *)(p+2);		int i,j,k;		float temp;		// temp w value		LONG tempx, tempy, tempw, tempfar;		ULONG cc,clipflag;		vertexCount = 0;		triangleCount = 0;		static float coldiv = 1.0f/255.0f;		switch(d3dptPrimitiveType)		{			case D3DPT_TRIANGLESTRIP:				for(j=0;j<dwIndexCount-2;j++)				{					if(v[lpwIndices[j]].flags & v[lpwIndices[j+1]].flags & v[lpwIndices[j+2]].flags)						continue;					TQAVTextureFlags *v2 = (TQAVTextureFlags *)&v1[vertexCount];					for(k=0;k<3;++k,++v2)					{						COL32* tc;						VTX_TL *vp = &v[lpwIndices[j+strip[j&1][k]]];						v2->x = vp->pnt.x;						v2->y = vp->pnt.y;						v2->z = vp->pnt.z;						v2->flags = vp->flags;						v2->uOverW = vp->u;						v2->vOverW = vp->v;						tc = (COL32 *)&vp->diffuse;						v2->kd_r = tc->comp.r*coldiv;						v2->kd_g = tc->comp.g*coldiv;						v2->kd_b = tc->comp.b*coldiv;						v2->a = tc->comp.a*coldiv;						if(j&1)						{							switch(k)							{								case 0:									v2->uOverW += 0.001;									break;								case 1:									v2->uOverW += 0.001;									v2->vOverW += 0.001;									break;								case 2:									v2->vOverW += 0.001;									break;							}						}						else						{							switch(k)							{								case 1:									v2->uOverW += 0.001;									break;								case 2:									v2->vOverW += 0.001;									break;							}						}					}					if(clipflag = (v[lpwIndices[j]].flags) | (v[lpwIndices[j+1]].flags) | (v[lpwIndices[j+2]].flags))					{						tVert=vertexCount;						triangle = &triangleArray[triangleCount];						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;						MacClipTriangle(triangle, clipFlagAll);						for(i=tVert;i<vertexCount;++i)						{							temp = v1[i].invW = 1.0 / v1[i].z;							v1[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							v1[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							v1[i].z = SetZ(v1[i].z);							v1[i].uOverW *= temp;							v1[i].vOverW *= temp;						}					}					else					{						for(i=vertexCount;i<vertexCount+3;++i)						{							temp = v1[i].invW = 1.0 / v1[i].z;							v1[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							v1[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							v1[i].z = SetZ(v1[i].z);							v1[i].uOverW *= temp;							v1[i].vOverW *= temp;						}						triangle = &triangleArray[triangleCount++];						triangle->triangleFlags = 0;						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;					}				}				break;			case D3DPT_TRIANGLELIST:				for(j=0;j<dwIndexCount;j+=3)				{					if(v[lpwIndices[j]].flags & v[lpwIndices[j+1]].flags & v[lpwIndices[j+2]].flags)						continue;					TQAVTextureFlags *v2 = (TQAVTextureFlags *)&v1[vertexCount];					for(k=0;k<3;++k,++v2)					{						COL32* tc;						VTX_TL *vp = &v[lpwIndices[j+k]];												v2->x = vp->pnt.x;						v2->y = vp->pnt.y;						v2->z = vp->pnt.z;						v2->flags = vp->flags;						v2->uOverW = vp->u;						v2->vOverW = vp->v;						tc = (COL32 *)&vp->diffuse;						v2->kd_r = tc->comp.r*coldiv;						v2->kd_g = tc->comp.g*coldiv;						v2->kd_b = tc->comp.b*coldiv;						v2->a = tc->comp.a*coldiv;						switch(k)						{							case 1:								v2->uOverW += 0.001;								break;							case 2:								v2->vOverW += 0.001;								break;						}					}					if(clipflag = (v[lpwIndices[j]].flags) | (v[lpwIndices[j+1]].flags) | (v[lpwIndices[j+2]].flags))					{						tVert=vertexCount;						triangle = &triangleArray[triangleCount];						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;						MacClipTriangle(triangle, clipFlagAll);						for(i=tVert;i<vertexCount;++i)						{							temp = v1[i].invW = 1.0 / v1[i].z;							v1[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							v1[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							v1[i].z = SetZ(v1[i].z);							v1[i].uOverW *= temp;							v1[i].vOverW *= temp;						}					}					else					{						for(i=vertexCount;i<vertexCount+3;++i)						{							temp = v1[i].invW = 1.0 / v1[i].z;							v1[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							v1[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							v1[i].z = SetZ(v1[i].z);							v1[i].uOverW *= temp;							v1[i].vOverW *= temp;						}						triangle = &triangleArray[triangleCount++];						triangle->triangleFlags = 0;						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;					}				}				break;		}		QASubmitVerticesTexture(d3dappi.gDrawContext,vertexCount,v1);		QADrawTriMeshTexture(d3dappi.gDrawContext,triangleCount,triangleArray);	}	else	{		int *p =(int *)vBuff;		int tVert;		VTX_TL *v;		v = (VTX_TL *)(p+2);		int i,j,k;		float temp;		// temp w value		LONG tempx, tempy, tempw, tempfar;		ULONG cc,clipflag;		vertexCount = 0;		triangleCount = 0;		static float coldiv = 1.0f/255.0f;		switch(d3dptPrimitiveType)		{			case D3DPT_TRIANGLESTRIP:				for(j=0;j<dwIndexCount-2;j++)				{					if(v[lpwIndices[j]].flags & v[lpwIndices[j+1]].flags & v[lpwIndices[j+2]].flags)						continue;					TQAVTextureFlags *v2 = (TQAVTextureFlags *)&v1[vertexCount];					for(k=0;k<3;++k,++v2)					{						COL32* tc;						VTX_TL *vp = &v[lpwIndices[j+strip[j&1][k]]];												v2->x = vp->pnt.x;						v2->y = vp->pnt.y;						v2->z = vp->pnt.z;						v2->flags = vp->flags;						v2->uOverW = vp->u;						v2->vOverW = vp->v;						tc = (COL32 *)&vp->diffuse;						v2->kd_r = tc->comp.r*coldiv;						v2->kd_g = tc->comp.g*coldiv;						v2->kd_b = tc->comp.b*coldiv;						v2->a = tc->comp.a*coldiv;					}					if(clipflag = (v[lpwIndices[j]].flags) | (v[lpwIndices[j+1]].flags) | (v[lpwIndices[j+2]].flags))					{						tVert=vertexCount;						triangle = &triangleArray[triangleCount];						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;						MacClipTriangle(triangle, clipFlagAll);						for(i=tVert;i<vertexCount;++i)						{							temp = vg[i].invW = 1.0 / v1[i].z;							vg[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							vg[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							vg[i].z = SetZ(v1[i].z);							vg[i].r = v1[i].kd_r;							vg[i].g = v1[i].kd_g;							vg[i].b = v1[i].kd_b;							vg[i].a = v1[i].a;						}					}					else					{						for(i=vertexCount;i<vertexCount+3;++i)						{							temp = vg[i].invW = 1.0 / v1[i].z;							vg[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							vg[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							vg[i].z = SetZ(v1[i].z);							vg[i].r = v1[i].kd_r;							vg[i].g = v1[i].kd_g;							vg[i].b = v1[i].kd_b;							vg[i].a = v1[i].a;						}						triangle = &triangleArray[triangleCount++];						triangle->triangleFlags = 0;						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;					}				}				break;			case D3DPT_TRIANGLELIST:				for(j=0;j<dwIndexCount;j+=3)				{					if(v[lpwIndices[j]].flags & v[lpwIndices[j+1]].flags & v[lpwIndices[j+2]].flags)						continue;					TQAVTextureFlags *v2 = (TQAVTextureFlags *)&v1[vertexCount];					for(k=0;k<3;++k,++v2)					{						COL32* tc;						VTX_TL *vp = &v[lpwIndices[j+k]];												v2->x = vp->pnt.x;						v2->y = vp->pnt.y;						v2->z = vp->pnt.z;						v2->flags = vp->flags;						v2->uOverW = vp->u;						v2->vOverW = vp->v;						tc = (COL32 *)&vp->diffuse;						v2->kd_r = tc->comp.r*coldiv;						v2->kd_g = tc->comp.g*coldiv;						v2->kd_b = tc->comp.b*coldiv;						v2->a = tc->comp.a*coldiv;					}					if(clipflag = (v[lpwIndices[j]].flags) | (v[lpwIndices[j+1]].flags) | (v[lpwIndices[j+2]].flags))					{						tVert=vertexCount;						triangle = &triangleArray[triangleCount];						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;						MacClipTriangle(triangle, clipFlagAll);						for(i=tVert;i<vertexCount;++i)						{							temp = vg[i].invW = 1.0 / v1[i].z;							vg[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							vg[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							vg[i].z = SetZ(v1[i].z);							vg[i].r = v1[i].kd_r;							vg[i].g = v1[i].kd_g;							vg[i].b = v1[i].kd_b;							vg[i].a = v1[i].a;						}					}					else					{						for(i=vertexCount;i<vertexCount+3;++i)						{							temp = vg[i].invW = 1.0 / v1[i].z;							vg[i].x = (v1[i].x * widthBy2) * temp  + widthBy2;							vg[i].y = (v1[i].y * -heightBy2) * temp + heightBy2;							vg[i].z = SetZ(v1[i].z);							vg[i].r = v1[i].kd_r;							vg[i].g = v1[i].kd_g;							vg[i].b = v1[i].kd_b;							vg[i].a = v1[i].a;						}						triangle = &triangleArray[triangleCount++];						triangle->triangleFlags = 0;						triangle->vertices[0]=vertexCount++;						triangle->vertices[1]=vertexCount++;						triangle->vertices[2]=vertexCount++;					}				}				break;		}		QASubmitVerticesGouraud(d3dappi.gDrawContext,vertexCount,vg);		QADrawTriMeshGouraud(d3dappi.gDrawContext,triangleCount,triangleArray);	}	return D3D_OK;}HRESULT MacSetRenderState(D3DRENDERSTATETYPE dwRenderStateType, DWORD dwRenderState){	switch(dwRenderStateType)	{		case D3DRENDERSTATE_ZWRITEENABLE://			QASetInt(d3dappi.gDrawContext, kQATag_ZBufferMask, dwRenderState?kQAZBufferMask_Enable:kQAZBufferMask_Disable);			break;		case D3DRENDERSTATE_ALPHABLENDENABLE:			QASetInt(d3dappi.gDrawContext, (TQATagInt)kATIGLAlphaEnable, dwRenderState? 1 : 0);			if(!dwRenderState)			{					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendSrc, GL_ONE);					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendDst, GL_ZERO);			}			break;		case D3DRENDERSTATE_SRCBLEND:			switch(dwRenderState)			{				case D3DBLEND_ONE:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendSrc, GL_ONE);					break;				case D3DBLEND_ZERO:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendSrc, GL_ZERO);					break;				default:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendSrc, GL_SRC_ALPHA);					break;			}			break;		case D3DRENDERSTATE_DESTBLEND:			switch(dwRenderState)			{				case D3DBLEND_ONE:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendDst, GL_ONE);					break;				case D3DBLEND_INVSRCCOLOR:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendDst, GL_ONE_MINUS_SRC_COLOR);					break;				case D3DBLEND_ZERO:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendDst, GL_ZERO);					break;				default:					QASetInt(d3dappi.gDrawContext, kQATagGL_BlendDst, GL_ONE_MINUS_SRC_ALPHA);					break;			}			break;		case D3DRENDERSTATE_CULLMODE:			switch(dwRenderState)			{				case D3DCULL_CW:					QASetInt(d3dappi.gDrawContext, (TQATagInt)kATICullMode, GL_FRONT);					break;				case D3DCULL_CCW:					QASetInt(d3dappi.gDrawContext, (TQATagInt)kATICullMode, GL_BACK);					break;				case D3DCULL_NONE:					QASetInt(d3dappi.gDrawContext, (TQATagInt)kATICullMode, 0);					break;			}			break;	}	return D3D_OK;}HRESULT MacSetTextureStageState(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue){	return D3D_OK;}